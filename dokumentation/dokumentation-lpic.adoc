= Dokumentation LPIC 1

== Kommandos

* `whoami` - Gibt den aktuellen Benutzer aus
* `pwd` _Present Working Directory_ - Gibt den absoluten Pfad des aktuellen Verzeichnisses an
* `ls` - Gibt den Inhalt des aktuellen Verzeichnisses aus
* `ls -a` - Gibt den Inhalt des aktuellen Verzeichnisses aus, _alles_, inkl. der versteckten Dateien/Verzeichnisse
* `ls -l` - Gibt den Inhalt des aktuellen Verzeichnisses aus, mit zusätzlichen Informationen zu den Dateien
* `cd` - _Change Directory_ - Wechselt in das angegebene Verzeichnis, ohne Optionen direkt in das Heimatverzeichnis
* `clear` - Leert den Bildschirm (`STRG+L`)
* `mkdir` - erstellt ein Verzeichnis
* `touch` - kann leere Dateien erstellen
* `cat` - Gibt den Inhalt von Dateien aus
* `rm` - löscht Dateien
* `date` - gibt das aktuellen Datum und Uhrzeit aus
* `date '+%d.%m.%Y'` git das Datum in folgendem Format aus: `16.05.2023`

== Hilfe auf der Kommandozeile

=== Manpages

 man <kommando>

== Sonderzeichen

=== Globbing Characters

Die Shell versucht immer, diese Sonderzeichen zu interpretieren

* `*` - Asterisk - steht für ein beliebiges Zeichen, dass *beliebig oft* vorkommen darf
* `?` - Fragezeichen - steht für ein beliebiges Zeichen, dass *exakt einmal* vorkommen darf
* ` ` - Leerzeichen - ist das *Trennzeichen*, trennt z.B. Kommando von Optionen und oder Argumenten etc.

== Maskieren / Escaping von Sonderzeichen

* `\` - Backslash - verhindert, dass die Shell das direkt darauf folgende Zeichen interpretiert
* alternativ können Sonderzeichen auch in einfache (`'`) oder doppelte (`"`) Anführungszeichen eingefasst werden
* es gibt einen Unterschied zwischen einfachen und doppelten Anführungszeichen

== Pfadangaben

=== absolut

Wegbeschreibung vom Wurzelverzeichnis `/` bis zum Ziel

 cd /home/tux/spielwiese/viele-dateien

=== relativ

Wegbeschreibung vom aktuellen Verzeichnis aus bis zum Ziel

 cd /home/tux/spielwiese
 cd viele-dateien

== Variablen

Erstellung einer Variablen und Zuweisung eines Wertes:

 my_var=hallo

Ausgabe des Inhalts einer Variablen (_Variablensubstitution_):

 echo $my_var

Das Dollarzeichen (`$`) ist wieder ein Sonderzeichen. Es weist die Shell an, eine _Substitution_ (Ersetzung) durchzuführen.

Variablen sind immer nur in der *aktuellen* Shell gültig, nicht in z.B. _Subshells_, also Shells, die innerhalt der aktuellen Shell laufen.

Will man Variablen auch in Subshells verfügbar machen, so muss man diese _exportieren_:

 export my_env_var=überall

 my_var=hallo
 export my_var

Variablen sind so lange gültig, wie die Shell existiert, in der sie definiert wurden.

Variablen können mit `unset` gelöscht werden:

 unset my_var

== History

Alle eingegebenen Kommandos werden in der _history_ gespeichert. Zuerst im Speicher und letztlich beim Beenden der Shell in der Datei `~/.bash_histroy`.

Einige wichtige Kommandos dazu:

* `history` ruft die gesamte history auf
* `history <anzahl>` zeigt nur die <anzahl> der letzten Einträge auf
* `!!` führt das letzte Kommanod erneut aus
* `!<zahl>` führt Kommando mit index <zahl> aus
* `!<zeichenfolge>` führt letztes Kommando aus, das mit `<zeichenfolge>` beginnt 
* `!?<zeichenfolge>` führt letztes Kommando aus, das `<zeichenfolge>` enthält
* `!$` repräsentiert das letzte Argument des zuletzt eingegebenen Kommandos

== Dateioperationen

* `mkdir verz` erstellt das Verzeichnis `verz`
* `cp quelle ziel` kopiert Datei `quelle` nach `ziel` (`ziel` kann/muss aber nicht existieren. Falls `ziel` existiert, wird die Datei *ohne Nachfrage* überschrieben
* `cp -r quell_verz ziel_verz` kopiert das *Verzeichnis* `quell_verz` in das Zielverzeichnis `ziel_verz`
* `mv quelle ziel` verschiebt `quelle` nach `ziel` (egal ob Datei oder Verzeichnis)
* `rm datei` löschte `datei` (ohne Nachfrage)
* `rm -r verz` löscht `verz` inkl. Inhalt
* `rmdir verz` löscht das *leere* Verzeichnis `verz`


== Aliase

Abkürzungen für z.B. längere/häufig benutzte Kommandos

 alias ll='ls -l'

Alias löschen:

 unalias ll

Alle Aliase anzeigen:

 alias

Aliase können persistent konfiguriert werden, z.B. in der Datei `~/.bashrc` bzw. in `~/.bash_aliases`

Nach Änderungen muss die Datei `~/.bashrc` neu eingelesen werden. Dies geschieht automatisch beim Start einer neuen BASH oder alternativ mit dem Kommanod `source` bzw. dessen Abkürzung `.`

 source ~/.bashrc
 . ~/.bashrc

== Konfigurationsdateien

=== Benutzerspezifische 

* beginnen immer mit einem Punkt bzw. befinden sich in einem Verzeichnis, das mit einem Punkt beginnt
* sind immer im Heimatverzeichnis des Nutzers

=== Systemweite

* alle systemweiten Konfigurationsdateien befinden sich im Verzeichnis `/etc`

== Textströme

=== UNIX Philosophie

1. Schreibe Programme so, dass sie *eine* Aufgabe erledigen und diese gut machen
2. Schreibe Programme so, dass sie zusammenarbeiten
3. Schreibe Programme so, dass sie Textströme verarbeiten, denn Text ist eine universelle Schnittstelle

Vereinfacht gesagt: Mache eine Sache und mache diese gut (KISS Prinzip)

* KISS: Keep it simple, stupid!
* KISS: Keep it stupid simple
* KISS: Keep it super simple

=== Standardkanäle

* `stdin` - Standardeingabekanal - `0`
* `stdout` - Standardausgabekanal - `1`
* `stderr` - Standardfehlerkanal - `2`

== Redirect

* Kanäle können umgeleitet werden, entweder in Dateien oder andere Kommandos
* `kommando 1>datei`: Ausgabe von `kommando` wird in Datei umgeleitet, Inhalt der Datei wird ersetzt
* `kommando > datei`: gleich wie oben, `1` kann weggelassen werden
* `kommando >> datei`: gleich wie oben, Inhalt wird an Datei angehängt
* `kommando < datei`: Inhalt von datei wird an die Standardeingabe von Kommando gesendet/umgeleitet
* Sowohl Ausgabe als auch Fehler in gleiche Datei leiten: `kommando >textdatei 2>&1` bzw. `kommando >& textdatei`
* `kommando1 | kommando2`: die Ausgabe (Kanal 1) von `kommando1` wird an die Eingabe (Kanal 0) von `kommando2` geleitet

== Filterkommandos

Textströme können mit Filterkommandos bearbeitet werden, so dass die Information, die uns interessiert, herausgefiltert werden kann.

* `cut`: schneidet Spalten aus tabellarisch aufgebauten Dateien aus (`cut -d: -f1 /etc/passwd`: nur die Benutzernamen ausgeben)
* `tail`: gibt die letzen (Standarmässig 10) Zeilen einer Datei aus (`tail -n5 /etc/passwd`: gibt die letzten 5 Zeilen der `passwd` aus)
* `grep`: sucht nach einem Suchbegriff innerhalb von Dateien/Textströmen und gibt die entsprechende Zeile aus (`grep bash /etc/passwd`: gibt alle Zeilen aus, in denen der String `bash` vorkommt)
* `grep -i <pattern>`: Gross- und Kleinschreibung von `<pattern>` ist egal
* `grep -n <pattern>`: Anzeige der Zeilennummer, in der `<pattern>` gefunden wurde
* `grep -r <pattern> dir/`: Rekursive Suche, so kann über alle Dateien in einem Verzeichnis _gegrept_ werden
* `grep -v <pattern>`: _inVert match_: Ausgabe wird _invertiert_, also nur die Zeilen ausgegeben, in denen `<pattern>` *nicht* vorkommt
* `tr`: übersetzt ein Zeichen in einem Textstrom (es können keine Dateien als Argument übergeben werden) in ein anderes/löscht dieses etc... (`tr a A < datei.txt`: wandelt jedes kleine `a` in ein grosses `A` um)
* `wc`: gibt die Anzahl der Zeilen, Wörter und Bytes einer Datei an (`wc -l /etc/passwd`: Anzahl Zeilen der Datei `/etc/passwd`)
* `tee`: verzweigt den Textstrom, so dass sowohl eine Ausgabe erfolgt, als auch in eine Datei geschrieben werden kann (`ls /etc | tee ls-etc.txt`)

== Kommandosubstitution

* `$(kommando)`: `kommando` wird (in einer Subshell) ausgeführt und durch sein Ergebnis ersetzt: 
  * Bsp.: Unterschied von `var=date` gegenüber `var=$(date)`:  
  
----
var=date
echo $var
> date   # String/Zeichenkette date wird ausgegeben
----

----
var=$(date)
echo $var
> Tue May 23 03:42:43 PM CEST 2023   # aktuelles Datum wird ausgegeben
----

* ``kommando``: ältere Syntax für die Kommandosubstitution

== echo

* `echo -e`: so kann `echo` gewisse Steuerungszeichen interpretieren, um z.B. einen Zeilenumbruch zu erzeugen, einen horizontalen oder vertikalen Tabulator, ein Backspace etc.
* diese Steuerungszeichen / Sequenzen beginnen mit einem `\` (Backslash)
* `echo -e '\n'`: echo gibt eine (zusätzliche) Leerzeile aus (echo an sich führt bereits einen Zeilenumbruch am Ende der Ausgabe aus, so erhalten wir also zwei Leerzeilen) 
* `\n` muss in diesem Fall _escaped/maskiert/gequotet_ werden, damit nicht die BASH, sondern das Kommando an sich (`echo`) den Backslash als Sonderzeichen interpretieren kann
* der Backslash muss sozusagen vor der Shell "versteckt" werden
* das Escapen kann sowohl durch Einfassen in einfache oder doppelete Anführungszeichen (`'` oder `"`) erfolgen, oder durch die Voranstellung eines Backslashs (`\`)

 echo -e '\n'
 echo -e "\n"
 echo -e \\n

* Unterschied von einfachen und doppelten Anführungszeichen bei der Substitution mit `$`:

 my_var=hallo
 echo '$my_var'
 > $my_var

 echo "$my_var"
 > hallo

=== Beispiele Kommandosubstitution und echo

 echo -e "Hallo, ich bin $(grep ${USER} /etc/passwd | cut -d: -f5 | cut -d, -f1).\n\nHeute ist der $(date '+%d.%m.%Y, %H:%M')." > username.txt

 echo -e "Hallo, ich bin $(grep $(whoami) /etc/passwd | cut -d: -f5 | cut -d, -f1).\n\nHeute ist der $(date '+%d.%m.%Y, %H:%M')." > username.txt

== Prozesse

Ein Programm resultiert immer in mindestens einem Prozess. Prozesse laufen jeweils in einem von anderen unabhängigen "Resourcenraum", haben eine eigene PID, kennen nur die PID des Prozesses, von dem sie gestartet wurden (Elternprozess). Prozesse können mit dem Kommando `kill` über _Signale_ beeinflusst werden.

Auf der Shell kann immer nur ein einzelner Prozess im Vordergrund ausgeführt werden. Prozesse können mit der Tastenkomnination `STRG+Z` angehalten und in den Hintergrund geschickt werden. Mit dem Kommando `bg` kann dieser Prozess dann im Hintergund fortgesetzt werden, `fg` holt den Prozess in den Vordergrund zurück.

* `ps -aux`: Anzeige aller laufende Prozessez
* `ps -ef`: auch Anzeige aller laufenden Prozesse
* `ps --forest`: Prozesshirarchie (Baumstruktur) anzeigen
* `jobs`: Anzeigen der Hintergrundprozesse
* `jobs %<jobnummer>`: bestimmten Job ansprechen
* `fg`: letzten/aktuellen/default Job in den Vordergrund holen
* `fg %<jobnummer>`: Job mit Jobnummer `<jobnummer>` in den Vordergrund holen
* `bg`: Hintergrundprozess fortsetzen
* `bg %<jobnummer>`: Hintergrundprozess mit Jobnummer `<jobnummer>` in fortsetzen
* `kill`: sendet Siganle an Prozesse 
* `kill -s <signal> <PID>`: sendet <signal> an Prozess mit der PID <PID>
* `kill -<signal> <PID>`: sendet <signal> an Prozess mit der PID <PID>
* `pkill`: analog zu oben, `pkill` erwartet aber den Namen bzw. einen Teil des Namesns eines Prozesses anstatt der PID
* `killall`: wie oben, erwartet aber den exakten Prozessnamen
* `pgrep`: PID laufender Prozesse ermitteln, ähnlich wie `ps -ef | grep`
* `nohup`: aufgerufener Prozess wird von der aufrufenden Shell gelöst, so dass dieser Prozess auch weiterläuft, wenn die aufrufenden Shell beendet wird
* `nohup ping 1.1.1.1 > ping.out`: Ausgabe von `ping` in Datei `ping.out` umleiten
* `tail -f`: fortlaufende Beobachtung einer Datei (neue Einträge werden automatisch angezeigt)
* `top`: Anzeige laufender Prozesse, ähnlich zum Taskmanager unter Windows, Prozesse können auch interaktiv beeinflusst werden
* `htop`: komfortablere Varinate von `top`











