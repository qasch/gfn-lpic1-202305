= Dokumentation LPIC 1

== Kommandos

* `whoami` - Gibt den aktuellen Benutzer aus
* `pwd` _Present Working Directory_ - Gibt den absoluten Pfad des aktuellen Verzeichnisses an
* `ls` - Gibt den Inhalt des aktuellen Verzeichnisses aus
* `ls -a` - Gibt den Inhalt des aktuellen Verzeichnisses aus, _alles_, inkl. der versteckten Dateien/Verzeichnisse
* `ls -l` - Gibt den Inhalt des aktuellen Verzeichnisses aus, mit zusätzlichen Informationen zu den Dateien
* `cd` - _Change Directory_ - Wechselt in das angegebene Verzeichnis, ohne Optionen direkt in das Heimatverzeichnis
* `clear` - Leert den Bildschirm (`STRG+L`)
* `mkdir` - erstellt ein Verzeichnis
* `touch` - kann leere Dateien erstellen
* `cat` - Gibt den Inhalt von Dateien aus
* `rm` - löscht Dateien
* `date` - gibt das aktuellen Datum und Uhrzeit aus
* `date '+%d.%m.%Y'` git das Datum in folgendem Format aus: `16.05.2023`

== Hilfe auf der Kommandozeile

=== Manpages

 man <kommando>

== Sonderzeichen

=== Globbing Characters

Die Shell versucht immer, diese Sonderzeichen zu interpretieren

* `*` - Asterisk - steht für ein beliebiges Zeichen, dass *beliebig oft* vorkommen darf
* `?` - Fragezeichen - steht für ein beliebiges Zeichen, dass *exakt einmal* vorkommen darf
* ` ` - Leerzeichen - ist das *Trennzeichen*, trennt z.B. Kommando von Optionen und oder Argumenten etc.

== Maskieren / Escaping von Sonderzeichen

* `\` - Backslash - verhindert, dass die Shell das direkt darauf folgende Zeichen interpretiert
* alternativ können Sonderzeichen auch in einfache (`'`) oder doppelte (`"`) Anführungszeichen eingefasst werden
* es gibt einen Unterschied zwischen einfachen und doppelten Anführungszeichen

== Pfadangaben

=== absolut

Wegbeschreibung vom Wurzelverzeichnis `/` bis zum Ziel

 cd /home/tux/spielwiese/viele-dateien

=== relativ

Wegbeschreibung vom aktuellen Verzeichnis aus bis zum Ziel

 cd /home/tux/spielwiese
 cd viele-dateien

== Variablen

Erstellung einer Variablen und Zuweisung eines Wertes:

 my_var=hallo

Ausgabe des Inhalts einer Variablen (_Variablensubstitution_):

 echo $my_var

Das Dollarzeichen (`$`) ist wieder ein Sonderzeichen. Es weist die Shell an, eine _Substitution_ (Ersetzung) durchzuführen.

Variablen sind immer nur in der *aktuellen* Shell gültig, nicht in z.B. _Subshells_, also Shells, die innerhalt der aktuellen Shell laufen.

Will man Variablen auch in Subshells verfügbar machen, so muss man diese _exportieren_:

 export my_env_var=überall

 my_var=hallo
 export my_var

Variablen sind so lange gültig, wie die Shell existiert, in der sie definiert wurden.

Variablen können mit `unset` gelöscht werden:

 unset my_var

== History

Alle eingegebenen Kommandos werden in der _history_ gespeichert. Zuerst im Speicher und letztlich beim Beenden der Shell in der Datei `~/.bash_histroy`.

Einige wichtige Kommandos dazu:

* `history` ruft die gesamte history auf
* `history <anzahl>` zeigt nur die <anzahl> der letzten Einträge auf
* `!!` führt das letzte Kommanod erneut aus
* `!<zahl>` führt Kommando mit index <zahl> aus
* `!<zeichenfolge>` führt letztes Kommando aus, das mit `<zeichenfolge>` beginnt 
* `!?<zeichenfolge>` führt letztes Kommando aus, das `<zeichenfolge>` enthält
* `!$` repräsentiert das letzte Argument des zuletzt eingegebenen Kommandos

== Dateioperationen

* `mkdir verz` erstellt das Verzeichnis `verz`
* `cp quelle ziel` kopiert Datei `quelle` nach `ziel` (`ziel` kann/muss aber nicht existieren. Falls `ziel` existiert, wird die Datei *ohne Nachfrage* überschrieben
* `cp -r quell_verz ziel_verz` kopiert das *Verzeichnis* `quell_verz` in das Zielverzeichnis `ziel_verz`
* `mv quelle ziel` verschiebt `quelle` nach `ziel` (egal ob Datei oder Verzeichnis)
* `rm datei` löschte `datei` (ohne Nachfrage)
* `rm -r verz` löscht `verz` inkl. Inhalt
* `rmdir verz` löscht das *leere* Verzeichnis `verz`


== Aliase

Abkürzungen für z.B. längere/häufig benutzte Kommandos

 alias ll='ls -l'

Alias löschen:

 unalias ll

Alle Aliase anzeigen:

 alias

Aliase können persistent konfiguriert werden, z.B. in der Datei `~/.bashrc` bzw. in `~/.bash_aliases`

Nach Änderungen muss die Datei `~/.bashrc` neu eingelesen werden. Dies geschieht automatisch beim Start einer neuen BASH oder alternativ mit dem Kommanod `source` bzw. dessen Abkürzung `.`

 source ~/.bashrc
 . ~/.bashrc

== Konfigurationsdateien

=== Benutzerspezifische 

* beginnen immer mit einem Punkt bzw. befinden sich in einem Verzeichnis, das mit einem Punkt beginnt
* sind immer im Heimatverzeichnis des Nutzers

=== Systemweite

* alle systemweiten Konfigurationsdateien befinden sich im Verzeichnis `/etc`

== Textströme

=== UNIX Philosophie

1. Schreibe Programme so, dass sie *eine* Aufgabe erledigen und diese gut machen
2. Schreibe Programme so, dass sie zusammenarbeiten
3. Schreibe Programme so, dass sie Textströme verarbeiten, denn Text ist eine universelle Schnittstelle

Vereinfacht gesagt: Mache eine Sache und mache diese gut (KISS Prinzip)

* KISS: Keep it simple, stupid!
* KISS: Keep it stupid simple
* KISS: Keep it super simple

=== Standardkanäle

* `stdin` - Standardeingabekanal - `0`
* `stdout` - Standardausgabekanal - `1`
* `stderr` - Standardfehlerkanal - `2`

== Redirect

* Kanäle können umgeleitet werden, entweder in Dateien oder andere Kommandos
* `kommando 1>datei`: Ausgabe von `kommando` wird in Datei umgeleitet, Inhalt der Datei wird ersetzt
* `kommando > datei`: gleich wie oben, `1` kann weggelassen werden
* `kommando >> datei`: gleich wie oben, Inhalt wird an Datei angehängt
* `kommando < datei`: Inhalt von datei wird an die Standardeingabe von Kommando gesendet/umgeleitet
* Sowohl Ausgabe als auch Fehler in gleiche Datei leiten: `kommando >textdatei 2>&1` bzw. `kommando >& textdatei`
* `kommando1 | kommando2`: die Ausgabe (Kanal 1) von `kommando1` wird an die Eingabe (Kanal 0) von `kommando2` geleitet

== Filterkommandos

Textströme können mit Filterkommandos bearbeitet werden, so dass die Information, die uns interessiert, herausgefiltert werden kann.

* `cut`: schneidet Spalten aus tabellarisch aufgebauten Dateien aus (`cut -d: -f1 /etc/passwd`: nur die Benutzernamen ausgeben)
* `tail`: gibt die letzen (Standarmässig 10) Zeilen einer Datei aus (`tail -n5 /etc/passwd`: gibt die letzten 5 Zeilen der `passwd` aus)
* `grep`: sucht nach einem Suchbegriff innerhalb von Dateien/Textströmen und gibt die entsprechende Zeile aus (`grep bash /etc/passwd`: gibt alle Zeilen aus, in denen der String `bash` vorkommt)
* `tr`: übersetzt ein Zeichen in einem Textstrom (es können keine Dateien als Argument übergeben werden) in ein anderes/löscht dieses etc... (`tr a A < datei.txt`: wandelt jedes kleine `a` in ein grosses `A` um)
* `wc`: gibt die Anzahl der Zeilen, Wörter und Bytes einer Datei an (`wc -l /etc/passwd`: Anzahl Zeilen der Datei `/etc/passwd`)
* `tee`: verzweigt den Textstrom, so dass sowohl eine Ausgabe erfolgt, als auch in eine Datei geschrieben werden kann (`ls /etc | tee ls-etc.txt`)















