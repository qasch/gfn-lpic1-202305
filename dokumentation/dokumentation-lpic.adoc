= Dokumentation LPIC 1

== Kommandos

* `whoami` - Gibt den aktuellen Benutzer aus
* `pwd` _Present Working Directory_ - Gibt den absoluten Pfad des aktuellen Verzeichnisses an
* `ls` - Gibt den Inhalt des aktuellen Verzeichnisses aus
* `ls -a` - Gibt den Inhalt des aktuellen Verzeichnisses aus, _alles_, inkl. der versteckten Dateien/Verzeichnisse
* `ls -l` - Gibt den Inhalt des aktuellen Verzeichnisses aus, mit zusätzlichen Informationen zu den Dateien
* `cd` - _Change Directory_ - Wechselt in das angegebene Verzeichnis, ohne Optionen direkt in das Heimatverzeichnis
* `clear` - Leert den Bildschirm (`STRG+L`)
* `mkdir` - erstellt ein Verzeichnis
* `touch` - kann leere Dateien erstellen
* `cat` - Gibt den Inhalt von Dateien aus
* `rm` - löscht Dateien
* `date` - gibt das aktuellen Datum und Uhrzeit aus
* `date '+%d.%m.%Y'` git das Datum in folgendem Format aus: `16.05.2023`

== Hilfe auf der Kommandozeile

=== Manpages

 man <kommando>

== Sonderzeichen

=== Globbing Characters

Die Shell versucht immer, diese Sonderzeichen zu interpretieren

* `*` - Asterisk - steht für ein beliebiges Zeichen, dass *beliebig oft* vorkommen darf
* `?` - Fragezeichen - steht für ein beliebiges Zeichen, dass *exakt einmal* vorkommen darf
* ` ` - Leerzeichen - ist das *Trennzeichen*, trennt z.B. Kommando von Optionen und oder Argumenten etc.

== Maskieren / Escaping von Sonderzeichen

* `\` - Backslash - verhindert, dass die Shell das direkt darauf folgende Zeichen interpretiert
* alternativ können Sonderzeichen auch in einfache (`'`) oder doppelte (`"`) Anführungszeichen eingefasst werden
* es gibt einen Unterschied zwischen einfachen und doppelten Anführungszeichen

== Pfadangaben

=== absolut

Wegbeschreibung vom Wurzelverzeichnis `/` bis zum Ziel

 cd /home/tux/spielwiese/viele-dateien

=== relativ

Wegbeschreibung vom aktuellen Verzeichnis aus bis zum Ziel

 cd /home/tux/spielwiese
 cd viele-dateien

== Variablen

Erstellung einer Variablen und Zuweisung eines Wertes:

 my_var=hallo

Ausgabe des Inhalts einer Variablen (_Variablensubstitution_):

 echo $my_var

Das Dollarzeichen (`$`) ist wieder ein Sonderzeichen. Es weist die Shell an, eine _Substitution_ (Ersetzung) durchzuführen.

Variablen sind immer nur in der *aktuellen* Shell gültig, nicht in z.B. _Subshells_, also Shells, die innerhalt der aktuellen Shell laufen.

Will man Variablen auch in Subshells verfügbar machen, so muss man diese _exportieren_:

 export my_env_var=überall

 my_var=hallo
 export my_var

Variablen sind so lange gültig, wie die Shell existiert, in der sie definiert wurden.

Variablen können mit `unset` gelöscht werden:

 unset my_var

== History

Alle eingegebenen Kommandos werden in der _history_ gespeichert. Zuerst im Speicher und letztlich beim Beenden der Shell in der Datei `~/.bash_histroy`.

Einige wichtige Kommandos dazu:

* `history` ruft die gesamte history auf
* `history <anzahl>` zeigt nur die <anzahl> der letzten Einträge auf
* `!!` führt das letzte Kommanod erneut aus
* `!<zahl>` führt Kommando mit index <zahl> aus
* `!<zeichenfolge>` führt letztes Kommando aus, das mit `<zeichenfolge>` beginnt 
* `!?<zeichenfolge>` führt letztes Kommando aus, das `<zeichenfolge>` enthält
* `!$` repräsentiert das letzte Argument des zuletzt eingegebenen Kommandos

== Dateioperationen

* `mkdir verz` erstellt das Verzeichnis `verz`
* `cp quelle ziel` kopiert Datei `quelle` nach `ziel` (`ziel` kann/muss aber nicht existieren. Falls `ziel` existiert, wird die Datei *ohne Nachfrage* überschrieben
* `cp -r quell_verz ziel_verz` kopiert das *Verzeichnis* `quell_verz` in das Zielverzeichnis `ziel_verz`
* `mv quelle ziel` verschiebt `quelle` nach `ziel` (egal ob Datei oder Verzeichnis)
* `rm datei` löschte `datei` (ohne Nachfrage)
* `rm -r verz` löscht `verz` inkl. Inhalt
* `rmdir verz` löscht das *leere* Verzeichnis `verz`


== Aliase

Abkürzungen für z.B. längere/häufig benutzte Kommandos

 alias ll='ls -l'

Alias löschen:

 unalias ll

Alle Aliase anzeigen:

 alias

Aliase können persistent konfiguriert werden, z.B. in der Datei `~/.bashrc` bzw. in `~/.bash_aliases`

Nach Änderungen muss die Datei `~/.bashrc` neu eingelesen werden. Dies geschieht automatisch beim Start einer neuen BASH oder alternativ mit dem Kommanod `source` bzw. dessen Abkürzung `.`

 source ~/.bashrc
 . ~/.bashrc

== Konfigurationsdateien

=== Benutzerspezifische 

* beginnen immer mit einem Punkt bzw. befinden sich in einem Verzeichnis, das mit einem Punkt beginnt
* sind immer im Heimatverzeichnis des Nutzers

=== Systemweite

* alle systemweiten Konfigurationsdateien befinden sich im Verzeichnis `/etc`

== Textströme

=== UNIX Philosophie

1. Schreibe Programme so, dass sie *eine* Aufgabe erledigen und diese gut machen
2. Schreibe Programme so, dass sie zusammenarbeiten
3. Schreibe Programme so, dass sie Textströme verarbeiten, denn Text ist eine universelle Schnittstelle

Vereinfacht gesagt: Mache eine Sache und mache diese gut (KISS Prinzip)

* KISS: Keep it simple, stupid!
* KISS: Keep it stupid simple
* KISS: Keep it super simple

=== Standardkanäle

* `stdin` - Standardeingabekanal - `0`
* `stdout` - Standardausgabekanal - `1`
* `stderr` - Standardfehlerkanal - `2`

== Redirect

* Kanäle können umgeleitet werden, entweder in Dateien oder andere Kommandos
* `kommando 1>datei`: Ausgabe von `kommando` wird in Datei umgeleitet, Inhalt der Datei wird ersetzt
* `kommando > datei`: gleich wie oben, `1` kann weggelassen werden
* `kommando >> datei`: gleich wie oben, Inhalt wird an Datei angehängt
* `kommando < datei`: Inhalt von datei wird an die Standardeingabe von Kommando gesendet/umgeleitet
* Sowohl Ausgabe als auch Fehler in gleiche Datei leiten: `kommando >textdatei 2>&1` bzw. `kommando >& textdatei`
* `kommando1 | kommando2`: die Ausgabe (Kanal 1) von `kommando1` wird an die Eingabe (Kanal 0) von `kommando2` geleitet

== Filterkommandos

* `grep`
* `cut`
* `wc`
















